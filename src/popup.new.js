// popup.js — streamlined Device Flow UI logic
// - Keeps sign-in instructions in the popup while opening the verification tab in the background.
// - Hides detection/upload steps until the user is authenticated and shows a single "Remember me" option.

const $ = id => document.getElementById(id);
let lastProblemData = null;
const workflowPanel = () => $('workflowPanel');
const deviceInfoPanel = () => $('deviceInfo');

function updateStatus(msg = '', isError = false) {
  const el = $('status');
  if (!el) return;
  el.textContent = msg;
  el.style.color = isError ? '#9b2c2c' : '#1f2937';
}

function updateAuthStatus(msg = '') {
  const el = $('authStatus');
  if (!el) return;
  el.textContent = msg;
}

function setWorkflowVisibility(show) {
  const panel = workflowPanel();
  if (!panel) return;
  panel.classList.toggle('hidden', !show);
}

function setDeviceInfoVisibility(show) {
  const panel = deviceInfoPanel();
  if (!panel) return;
  panel.classList.toggle('hidden', !show);
}

function setAuthenticatedState(authenticated, maskedToken = '') {
  const signInBtn = $('signInBtn');
  const signOutBtn = $('signOutBtn');
  if (signInBtn) signInBtn.style.display = authenticated ? 'none' : '';
  if (signOutBtn) signOutBtn.style.display = authenticated ? '' : 'none';
  setWorkflowVisibility(authenticated);
  if (!authenticated) {
    setDeviceInfoVisibility(false);
  }
  updateAuthStatus(authenticated ? `Signed in • ${maskedToken}` : 'Not signed in');
}

function showMeta(data) {
  if (!data) {
    $('metaTitle').textContent = 'No problem detected';
    $('metaIdUrl').textContent = '';
    $('metaDifficulty').textContent = '';
    $('metaTags').innerHTML = '';
    $('metaLangExt').textContent = '';
    $('detectedPath').textContent = '/0000-unknown/';
    lastProblemData = null;
    return;
  }
  lastProblemData = data;
  $('metaTitle').textContent = `${data.id || '0000'} — ${data.title}`;
  $('metaIdUrl').textContent = data.url || '';
  $('metaDifficulty').textContent = data.difficulty ? `Difficulty: ${data.difficulty}` : '';
  $('metaTags').innerHTML = (data.tags || []).map(t => `<span class="tag">${t}</span>`).join(' ');
  $('metaLangExt').textContent = `Detected language: ${data.language || 'unknown'} — .${data.extension || 'txt'}`;
  $('detectedPath').textContent = `/${data.folderName}/`;
}

function queryActiveTab() {
  return new Promise((resolve) => {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => resolve(tabs));
  });
}

async function onDetect() {
  updateStatus('Detecting problem...');
  try {
    const tabs = await queryActiveTab();
    if (!tabs || tabs.length === 0) throw new Error('No active tab found');
    const tabId = tabs[0].id;

    try {
      await new Promise((resolve) => {
        chrome.scripting.executeScript({ target: { tabId }, files: ['src/content.js'] }, () => resolve());
      });
    } catch (e) {
      console.warn('Injection attempt error', e);
    }

    await new Promise(r => setTimeout(r, 250));

    chrome.tabs.sendMessage(tabId, { action: 'getProblemData' }, (response) => {
      if (chrome.runtime.lastError || !response || !response.success) {
        updateStatus('Unable to detect problem on this tab.', true);
        showMeta(null);
        return;
      }
      showMeta(response.data);
      updateStatus('Problem detected. Click Save to upload.');
    });
  } catch (err) {
    updateStatus(err.message || 'Detection failed', true);
  }
}

function buildReadme(problemData) {
  const title = problemData.title || '';
  const url = problemData.url || '';
  const tags = (problemData.tags || []).join(', ');
  const difficulty = problemData.difficulty || '';
  const description = (function strip() {
    if (!problemData.contentHtml) return '';
    try {
      const div = document.createElement('div');
      div.innerHTML = problemData.contentHtml;
      return div.textContent || div.innerText || '';
    } catch {
      return problemData.contentHtml;
    }
  })().trim();

  const lines = [];
  lines.push(`# ${title}`);
  lines.push('');
  if (difficulty) lines.push(`**Difficulty:** ${difficulty}`);
  if (tags) lines.push(`**Tags:** ${tags}`);
  if (url) lines.push(`**URL:** ${url}`);
  lines.push('');
  if (description) {
    lines.push('## Problem');
    lines.push('');
    lines.push(description);
    lines.push('');
  }
  lines.push('---');
  lines.push('_Generated by LeetCode → GitHub Chrome extension_');
  return lines.join('\n');
}

function loadSavedDefaults() {
  chrome.storage.local.get(['github_owner', 'github_repo', 'github_branch', 'remember_me'], (items) => {
    if (!items) return;
    if (items.github_owner) $('owner').value = items.github_owner;
    if (items.github_repo) $('repo').value = items.github_repo;
    if (items.github_branch) $('branch').value = items.github_branch;
    $('rememberMe').checked = !!items.remember_me;
  });
}

function saveDefaultsIfWanted() {
  const remember = !!$('rememberMe').checked;
  if (!remember) {
    chrome.storage.local.remove(['github_owner', 'github_repo', 'github_branch', 'remember_me']);
    return;
  }
  const owner = $('owner').value.trim();
  const repo = $('repo').value.trim();
  const branch = $('branch').value.trim() || 'main';
  chrome.storage.local.set({
    github_owner: owner,
    github_repo: repo,
    github_branch: branch,
    remember_me: true
  });
}

async function checkAuthStatus() {
  return new Promise((resolve) => {
    chrome.runtime.sendMessage({ action: 'getAuthStatus' }, (resp) => {
      if (chrome.runtime.lastError || !resp || !resp.success) {
        setAuthenticatedState(false);
        return resolve({ authenticated: false });
      }
      setAuthenticatedState(resp.authenticated, resp.tokenMasked || '');
      resolve(resp);
    });
  });
}

function openAuthTab(url, { active = false } = {}) {
  if (!url) return;
  try {
    chrome.tabs.create({ url, active }, () => {
      updateStatus('GitHub tab opened. Paste the code there.');
    });
  } catch (err) {
    window.open(url, '_blank', 'noopener');
    updateStatus('Unable to open GitHub tab automatically.', true);
  }
}

function bindEvents() {
  $('detectBtn').addEventListener('click', onDetect);
  $('saveBtn').addEventListener('click', onSave);

  $('signInBtn').addEventListener('click', () => {
    const remember = !!$('rememberMe').checked;
    updateAuthStatus('Starting GitHub authorization...');
    chrome.runtime.sendMessage({ action: 'startDeviceFlow', remember }, (resp) => {
      if (chrome.runtime.lastError || !resp || !resp.success) {
        updateAuthStatus('Authorization failed to start.');
        return;
      }
      const device = resp.device;
      const url = device.verification_uri_complete || device.verification_uri;
      $('deviceUrl').textContent = url || 'GitHub verification page';
      $('deviceUrl').href = url || '#';
      $('deviceCode').textContent = device.user_code || '—';
      setDeviceInfoVisibility(true);
      updateAuthStatus('Device Flow in progress. Complete the code in the opened tab.');
      openAuthTab(url);
    });
  });

  $('signOutBtn').addEventListener('click', () => {
    chrome.runtime.sendMessage({ action: 'signOut' }, (resp) => {
      if (chrome.runtime.lastError) {
        updateAuthStatus('Sign out failed.');
        return;
      }
      setAuthenticatedState(false);
      updateStatus('Signed out.');
    });
  });

  $('copyCodeBtn').addEventListener('click', () => {
    const code = $('deviceCode').textContent || '';
    if (!code || code === '—') {
      updateStatus('No code to copy.', true);
      return;
    }
    navigator.clipboard.writeText(code).then(() => {
      updateStatus('Code copied.');
    }).catch(() => {
      updateStatus('Unable to copy code.', true);
    });
  });

  $('openUrlBtn').addEventListener('click', () => {
    const url = $('deviceUrl').href || '';
    if (!url || url === '#') {
      updateStatus('No GitHub URL available.', true);
      return;
    }
    openAuthTab(url, { active: true });
  });

  $('helpLink').addEventListener('click', (event) => {
    event.preventDefault();
    if (chrome.runtime.openOptionsPage) {
      chrome.runtime.openOptionsPage();
    } else {
      chrome.tabs.create({ url: chrome.runtime.getURL('src/options.html') });
    }
  });

  chrome.runtime.onMessage.addListener((message) => {
    if (!message || !message.action) return;
    switch (message.action) {
      case 'deviceFlowSuccess':
        setAuthenticatedState(true, message.tokenMasked || '');
        setDeviceInfoVisibility(false);
        updateStatus('Signed in. You can now upload your solution.');
        break;
      case 'deviceFlowError':
        setDeviceInfoVisibility(false);
        updateAuthStatus('Authorization error.');
        updateStatus(message.message || 'Authorization failed.', true);
        break;
      case 'deviceFlowExpired':
        setDeviceInfoVisibility(false);
        setAuthenticatedState(false);
        updateStatus('Device flow expired. Retry sign in.', true);
        break;
      case 'deviceFlowDenied':
        setDeviceInfoVisibility(false);
        updateAuthStatus('Authorization denied.');
        updateStatus('Authorization denied by user.', true);
        break;
      case 'signedOut':
        setAuthenticatedState(false);
        updateStatus('Signed out.');
        break;
      default:
        break;
    }
  });
}

async function onSave() {
  updateStatus('Preparing files...');
  if (!lastProblemData) {
    updateStatus('Detect a problem first.', true);
    return;
  }
  const owner = $('owner').value.trim();
  const repo = $('repo').value.trim();
  const branch = ($('branch').value || 'main').trim();
  const allowUpdate = $('allowUpdate').checked;

  if (!owner || !repo) {
    updateStatus('Provide GitHub owner and repository.', true);
    return;
  }

  const auth = await new Promise(resolve => chrome.runtime.sendMessage({ action: 'getAuthStatus' }, resolve));
  if (!auth || !auth.success || !auth.authenticated) {
    updateStatus('Not signed in. Please sign in with GitHub first.', true);
    return;
  }

  saveDefaultsIfWanted();

  const folder = lastProblemData.folderName;
  const solutionName = `solution.${lastProblemData.extension || 'txt'}`;
  const solutionContent = lastProblemData.code || '';
  const readmeContent = buildReadme(lastProblemData);

  updateStatus('Uploading to GitHub...');

  const payload = {
    action: 'uploadFiles',
    owner,
    repo,
    branch,
    folder,
    files: [
      { path: `${folder}/${solutionName}`, content: solutionContent, isBase64: false },
      { path: `${folder}/README.md`, content: readmeContent, isBase64: false }
    ],
    allowUpdate
  };

  chrome.runtime.sendMessage(payload, (resp) => {
    if (chrome.runtime.lastError) {
      updateStatus(`Upload failed: ${chrome.runtime.lastError.message}`, true);
      return;
    }
    if (!resp) {
      updateStatus('No response from background.', true);
      return;
    }
    if (resp.success) {
      updateStatus(resp.message || 'Upload succeeded.');
    } else {
      updateStatus(resp.message || 'Upload failed.', true);
    }
  });
}

document.addEventListener('DOMContentLoaded', async () => {
  bindEvents();
  loadSavedDefaults();
  setWorkflowVisibility(false);
  setDeviceInfoVisibility(false);
  await checkAuthStatus();
  updateStatus('');
});
