import { formatAsComment } from "./languageUtils.js";
import { fillTemplate } from "./templateEngine.js";
import { TemplateManager } from "./templateManager.js";

/**
 * Clean HTML content to plain text / simple markdown
 */
export function cleanDescription(html) {
    if (!html) return "";
    const decoded = html
        // Strip MathJax script containers first
        .replace(/<script type="math\/tex">([\s\S]*?)<\/script>/gi, " $1 ")
        .replace(/<(p|div|br|li|h1|h2|h3|h4|h5|h6)[^>]*>/gi, "\n")
        .replace(/<[^>]+>/g, "")
        // Codeforces specific: $$$x$$$ -> $x$
        .replace(/\$\$\$/g, "$")
        // General LaTeX: \( x \) -> $x$, \[ x \] -> $$x$$
        .replace(/\\\(|\\\)/g, "$")
        .replace(/\\\[|\\\]/g, "$$")
        // Cleanup MathJax noise patterns like MathJax.Hub or [MathJax] artifacts
        .replace(/(MathJax|Math)\.[^ \n]+/gi, "")
        .replace(/\[MathJax\]/gi, "")
        .replace(/\n\s*\n+/g, "\n\n")
        .trim();

    return decodeHtmlEntities(decoded);
}

function decodeHtmlEntities(text) {
    if (!text) return "";
    return text
        .replace(/&nbsp;/g, " ")
        .replace(/&lt;/g, "<")
        .replace(/&gt;/g, ">")
        .replace(/&amp;/g, "&")
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&apos;/g, "'")
        .replace(/&#(\d+);/g, (_, code) => {
            const num = Number(code);
            return Number.isFinite(num) ? String.fromCharCode(num) : _;
        })
        .replace(/&#x([0-9a-fA-F]+);/g, (_, hex) => {
            const num = parseInt(hex, 16);
            return Number.isFinite(num) ? String.fromCharCode(num) : _;
        });
}

/**
 * Generate the README markdown content
 * @param {Object} problemData
 * @param {string} template - optional markdown template
 * @returns {string}
 */
export function buildReadmeContent(problemData, template = null, options = {}) {
    try {
        const rawHtml = problemData.contentHtml || "";
        const descriptionClean = cleanDescription(rawHtml);
        const description = descriptionClean || rawHtml;
        const note = (problemData.note || "").trim();
        const dataForTemplate = { ...problemData, description, note };
        const includeProblemStatement =
            options.includeProblemStatement !== false;

        if (template) {
            const templated = TemplateManager.buildReadme(
                dataForTemplate,
                template,
                { includeProblemStatement },
            );
            return appendCreditIfMissing(templated);
        }

        const title = problemData.title || "";
        const url = problemData.url || "";
        const tags = (problemData.tags || []).join(", ");
        const difficulty = problemData.difficulty || "";
        const solveTime = problemData.solveTime || "";
        const attemptCount =
            typeof problemData.attemptCount === "number"
                ? problemData.attemptCount
                : null;

        const lines = [];
        lines.push(`# ${title}`);
        lines.push("");
        if (difficulty) lines.push(`**Difficulty:** ${difficulty}`);
        if (solveTime) lines.push(`**Time:** ${solveTime}`);
        if (attemptCount !== null)
            lines.push(`**Attempts:** ${attemptCount}`);
        if (tags) lines.push(`**Tags:** ${tags}`);
        if (url) lines.push(`**URL:** ${url}`);
        lines.push("");
        if (includeProblemStatement && description) {
            lines.push("## Problem");
            lines.push("");
            lines.push(description);
            lines.push("");
        }
        if (note) {
            lines.push("## Note");
            lines.push("");
            lines.push(note);
            lines.push("");
        }
        lines.push("---");
        lines.push("_Generated by CodeBridge_");
        return lines.join("\n");
    } catch (e) {
        console.error("buildReadmeContent error:", e);
        return appendCreditIfMissing(
            `# ${problemData.title || "Problem"}\n\n${problemData.url || ""}`,
        );
    }
}

function appendCreditIfMissing(markdown) {
    if (!markdown) return "_Generated by CodeBridge_";
    if (/generated by codebridge/i.test(markdown)) return markdown;
    return `${markdown}\n\n---\n_Generated by CodeBridge_`;
}

/**
 * Generate the list of files to upload based on the selected strategy
 * @param {string} strategy - 'folder' or 'flat'
 * @param {Object} problemData - data gathered from LeetCode
 * @param {string} chosenExt - file extension (e.g. 'py')
 * @param {Object} templates - optional custom templates
 * @returns {Array<{path: string, content: string}>}
 */
export function generateUploadFiles(
    strategy,
    problemData,
    chosenExt,
    templates = {},
    options = {},
) {
    const description = cleanDescription(problemData.contentHtml || "");
    const note = (problemData.note || "").trim();
    const dataWithDesc = { ...problemData, description, note };
    const includeProblemStatement = options.includeProblemStatement !== false;

    const solutionBody = problemData.code || "";
    const readmeContent = buildReadmeContent(problemData, templates.readme, {
        includeProblemStatement,
    });

    // Build the header based on user template
    const header = TemplateManager.buildSolutionHeader(
        dataWithDesc,
        templates.solutionHeader,
        chosenExt,
    );
    let solutionContent = header
        ? `${header}\n\n${solutionBody}`
        : solutionBody;
    const solveTime = problemData.solveTime || "";
    const attemptCount =
        typeof problemData.attemptCount === "number"
            ? problemData.attemptCount
            : null;
    const wantsDescriptionComment = description && includeProblemStatement;
    const wantsNoteComment = !!note;
    const wantsMetaComment = !!(
        dataWithDesc.title ||
        dataWithDesc.difficulty ||
        dataWithDesc.url ||
        solveTime
    );
    if (strategy === "flat" && (wantsDescriptionComment || wantsMetaComment)) {
        const metaLines = [];
        if (dataWithDesc.title) metaLines.push(`Title: ${dataWithDesc.title}`);
        if (dataWithDesc.difficulty)
            metaLines.push(`Difficulty: ${dataWithDesc.difficulty}`);
        if (solveTime) metaLines.push(`Time: ${solveTime}`);
        if (attemptCount !== null)
            metaLines.push(`Attempts: ${attemptCount}`);
        if (dataWithDesc.url) metaLines.push(`URL: ${dataWithDesc.url}`);
        if (wantsDescriptionComment) {
            metaLines.push("");
            metaLines.push(description);
        }
        if (wantsNoteComment) {
            metaLines.push("");
            metaLines.push("Note:");
            metaLines.push(note);
        }
        metaLines.push("");
        metaLines.push("Generated by CodeBridge");
        const commentBlock = formatAsComment(metaLines.join("\n"), chosenExt);
        solutionContent = `${commentBlock}\n\n${solutionContent}`;
    }

    // Strategy: FOLDER (Default)
    if (strategy !== "flat") {
        let solutionPath = `${problemData.folderName}/solution.${chosenExt}`;
        let readmePath = `${problemData.folderName}/README.md`;

        if (templates.path) {
            solutionPath = fillTemplate(templates.path, {
                ...problemData,
                extension: chosenExt,
            });
            const lastSlash = solutionPath.lastIndexOf("/");
            if (lastSlash !== -1) {
                const dir = solutionPath.substring(0, lastSlash);
                readmePath = `${dir}/README.md`;
            } else {
                readmePath = `README-${problemData.folderName}.md`;
            }
        }

        return [
            { path: solutionPath, content: solutionContent },
            { path: readmePath, content: readmeContent },
        ];
    }

    // Strategy: FLAT
    let flatPath = `${problemData.folderName}.${chosenExt}`;
    if (templates.path) {
        flatPath = fillTemplate(templates.path, {
            ...problemData,
            extension: chosenExt,
        });
    }

    // For flat strategy, we usually don't have a separate README, but we already prepended the header to solutionContent.
    // If the user REALLY wants the full README content for flat files, we can use the old behavior or let them decide.
    // For now, let's keep it consistent: Header + Code.
    return [{ path: flatPath, content: solutionContent }];
}
