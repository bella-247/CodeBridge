import { formatAsComment } from "./languageUtils.js";
import { fillTemplate } from "./templateEngine.js";

/**
 * Generate the README markdown content
 * @param {Object} problemData 
 * @param {string} template - optional markdown template
 * @returns {string}
 */
export function buildReadmeContent(problemData, template = null) {
    try {
        if (template) {
            return fillTemplate(template, problemData);
        }

        const title = problemData.title || "";
        const url = problemData.url || "";
        const tags = (problemData.tags || []).join(", ");
        const difficulty = problemData.difficulty || "";

        let description = "";
        if (problemData.contentHtml) {
            // Intelligent clean: preserve block elements as newlines
            description = problemData.contentHtml
                // Strip MathJax script containers first
                .replace(/<script type="math\/tex">([\s\S]*?)<\/script>/gi, " $1 ")
                .replace(/<(p|div|br|li|h1|h2|h3|h4|h5|h6)[^>]*>/gi, "\n")
                .replace(/<[^>]+>/g, "")
                // Codeforces specific: $$$x$$$ -> $x$
                .replace(/\$\$\$/g, "$")
                // General LaTeX: \( x \) -> $x$, \[ x \] -> $$x$$
                .replace(/\\\(|\\\)/g, "$")
                .replace(/\\\[|\\\]/g, "$$")
                // Cleanup MathJax noise patterns like MathJax.Hub or [MathJax] artifacts
                .replace(/(MathJax|Math)\.[^ \n]+/gi, "")
                .replace(/\[MathJax\]/gi, "")
                .replace(/\n\s*\n+/g, "\n\n")
                .trim();
        }

        const lines = [];
        lines.push(`# ${title}`);
        lines.push("");
        if (difficulty) lines.push(`**Difficulty:** ${difficulty}`);
        if (tags) lines.push(`**Tags:** ${tags}`);
        if (url) lines.push(`**URL:** ${url}`);
        lines.push("");
        if (description) {
            lines.push("## Problem");
            lines.push("");
            lines.push(description);
            lines.push("");
        }
        lines.push("---");
        lines.push("_Generated by CodeBridge_");
        return lines.join("\n");
    } catch (e) {
        console.error("buildReadmeContent error:", e);
        return `# ${problemData.title || "Problem"}\n\n${problemData.url || ""}`;
    }
}

/**
 * Generate the list of files to upload based on the selected strategy
 * @param {string} strategy - 'folder' or 'flat'
 * @param {Object} problemData - data gathered from LeetCode
 * @param {string} chosenExt - file extension (e.g. 'py')
 * @param {Object} templates - optional custom templates
 * @returns {Array<{path: string, content: string}>}
 */
export function generateUploadFiles(strategy, problemData, chosenExt, templates = {}) {
    const solutionContent = problemData.code || "";
    const readmeContent = buildReadmeContent(problemData, templates.readme);

    // Strategy: FOLDER (Default)
    if (strategy !== 'flat') {
        let solutionPath = `${problemData.folderName}/solution.${chosenExt}`;
        let readmePath = `${problemData.folderName}/README.md`;

        if (templates.path) {
            solutionPath = fillTemplate(templates.path, { ...problemData, extension: chosenExt });
            // If user provided a path template, we might not know where to put the README 
            // unless they provide a specific README path template too. 
            // For now, if path template is used, we'll put README in the same dir as the solution.
            const dir = solutionPath.substring(0, solutionPath.lastIndexOf('/'));
            readmePath = dir ? `${dir}/README.md` : `README-${problemData.folderName}.md`;
        }

        return [
            { path: solutionPath, content: solutionContent },
            { path: readmePath, content: readmeContent }
        ];
    }

    // Strategy: FLAT
    let flatPath = `${problemData.folderName}.${chosenExt}`;
    if (templates.path) {
        flatPath = fillTemplate(templates.path, { ...problemData, extension: chosenExt });
    }

    const descriptionComment = formatAsComment(readmeContent, chosenExt);
    const combinedContent = `${descriptionComment}\n\n${solutionContent}`;

    return [
        { path: flatPath, content: combinedContent }
    ];
}
