import { formatAsComment } from "./languageUtils.js";
import { fillTemplate } from "./templateEngine.js";
import { TemplateManager } from "./templateManager.js";

/**
 * Clean HTML content to plain text / simple markdown
 */
export function cleanDescription(html) {
    if (!html) return "";
    return html
        // Strip MathJax script containers first
        .replace(/<script type="math\/tex">([\s\S]*?)<\/script>/gi, " $1 ")
        .replace(/<(p|div|br|li|h1|h2|h3|h4|h5|h6)[^>]*>/gi, "\n")
        .replace(/<[^>]+>/g, "")
        // Codeforces specific: $$$x$$$ -> $x$
        .replace(/\$\$\$/g, "$")
        // General LaTeX: \( x \) -> $x$, \[ x \] -> $$x$$
        .replace(/\\\(|\\\)/g, "$")
        .replace(/\\\[|\\\]/g, "$$")
        // Cleanup MathJax noise patterns like MathJax.Hub or [MathJax] artifacts
        .replace(/(MathJax|Math)\.[^ \n]+/gi, "")
        .replace(/\[MathJax\]/gi, "")
        .replace(/\n\s*\n+/g, "\n\n")
        .trim();
}

/**
 * Generate the README markdown content
 * @param {Object} problemData 
 * @param {string} template - optional markdown template
 * @returns {string}
 */
export function buildReadmeContent(problemData, template = null) {
    try {
        const description = cleanDescription(problemData.contentHtml || "");
        const dataForTemplate = { ...problemData, description };

        if (template) {
            return TemplateManager.buildReadme(dataForTemplate, template);
        }

        const title = problemData.title || "";
        const url = problemData.url || "";
        const tags = (problemData.tags || []).join(", ");
        const difficulty = problemData.difficulty || "";

        const lines = [];
        lines.push(`# ${title}`);
        lines.push("");
        if (difficulty) lines.push(`**Difficulty:** ${difficulty}`);
        if (tags) lines.push(`**Tags:** ${tags}`);
        if (url) lines.push(`**URL:** ${url}`);
        lines.push("");
        if (description) {
            lines.push("## Problem");
            lines.push("");
            lines.push(description);
            lines.push("");
        }
        lines.push("---");
        lines.push("_Generated by CodeBridge_");
        return lines.join("\n");
    } catch (e) {
        console.error("buildReadmeContent error:", e);
        return `# ${problemData.title || "Problem"}\n\n${problemData.url || ""}`;
    }
}

/**
 * Generate the list of files to upload based on the selected strategy
 * @param {string} strategy - 'folder' or 'flat'
 * @param {Object} problemData - data gathered from LeetCode
 * @param {string} chosenExt - file extension (e.g. 'py')
 * @param {Object} templates - optional custom templates
 * @returns {Array<{path: string, content: string}>}
 */
export function generateUploadFiles(strategy, problemData, chosenExt, templates = {}) {
    const description = cleanDescription(problemData.contentHtml || "");
    const dataWithDesc = { ...problemData, description };

    const solutionBody = problemData.code || "";
    const readmeContent = buildReadmeContent(problemData, templates.readme);

    // Build the header based on user template
    const header = TemplateManager.buildSolutionHeader(dataWithDesc, templates.solutionHeader, chosenExt);
    const solutionContent = header ? `${header}\n\n${solutionBody}` : solutionBody;

    // Strategy: FOLDER (Default)
    if (strategy !== 'flat') {
        let solutionPath = `${problemData.folderName}/solution.${chosenExt}`;
        let readmePath = `${problemData.folderName}/README.md`;

        if (templates.path) {
            solutionPath = fillTemplate(templates.path, { ...problemData, extension: chosenExt });
            const lastSlash = solutionPath.lastIndexOf('/');
            if (lastSlash !== -1) {
                const dir = solutionPath.substring(0, lastSlash);
                readmePath = `${dir}/README.md`;
            } else {
                readmePath = `README-${problemData.folderName}.md`;
            }
        }

        return [
            { path: solutionPath, content: solutionContent },
            { path: readmePath, content: readmeContent }
        ];
    }

    // Strategy: FLAT
    let flatPath = `${problemData.folderName}.${chosenExt}`;
    if (templates.path) {
        flatPath = fillTemplate(templates.path, { ...problemData, extension: chosenExt });
    }

    // For flat strategy, we usually don't have a separate README, but we already prepended the header to solutionContent.
    // If the user REALLY wants the full README content for flat files, we can use the old behavior or let them decide.
    // For now, let's keep it consistent: Header + Code.
    return [
        { path: flatPath, content: solutionContent }
    ];
}
